<!doctype html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
</head>

<body>

    <script src="js/three.js"></script>
    <script src="js/cannon.js"></script>
    <script type="module">
        import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

        const FPS = 60;
        const table_x = 31;
        const table_z = 17;
        const raio_ball = 0.524;
        const raio_t = 0.674
        var world;

        var pontuacao = 0;

        var elements_page = [];

        // Cria CANNON WORLD
        world = new CANNON.World();
        world.gravity.set(0.0, -9.8, 0.0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 40000;

        // Create THREEJS 
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x000000, 0);
        const loader = new THREE.TextureLoader();
        loader.load('https://i.pinimg.com/originals/39/ec/d1/39ecd18dfe039f474138051777c6f0b9.gif', function (texture) {
            scene.background = texture;
        });
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);

        // Haja Luz - THREEJS
        //const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
        //scene.add(light);


        const spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(100, 50, 20);

        spotLight.castShadow = true;

        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;

        spotLight.shadow.camera.near = 500;
        spotLight.shadow.camera.far = 4000;
        spotLight.shadow.camera.fov = 30;

        
        scene.add(spotLight);

        const spotLight2 = new THREE.SpotLight(0xccffff);
        spotLight2.position.set(-100, 50, 20);
        spotLight2.castShadow = true;
        spotLight2.shadow.mapSize.width = 1024;
        spotLight2.shadow.mapSize.height = 1024;
        spotLight2.shadow.camera.near = 500;
        spotLight2.shadow.camera.far = 4000;
        spotLight2.shadow.camera.fov = 30;

        
        scene.add(spotLight2);

        // Mesa - THREEJS

        //      Material CANNON MESA
        var wall_mat = new CANNON.Material({ friction: 0.1, restitution: 0.7 });


        //      Tampo mesa
        var x1 = table_x - (raio_ball * 8);
        var z1 = table_z - (raio_ball * 8);
        var geometry = new THREE.BoxBufferGeometry(x1, 1, table_z);
        const material = new THREE.MeshStandardMaterial({ color: 0x00cc00 });
        var mesa = new THREE.Mesh(geometry, material);


        var groundShape = new CANNON.Box(new CANNON.Vec3(x1 / 2, 1 / 2, table_z / 2));
        groundShape.material = new CANNON.Material({ friction: 0.1, restitution: 0.1 });

        var groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
        groundBody.position.set(0, 0, 0);


        elements_page.push([mesa, groundBody, "floor"]);

        geometry = new THREE.BoxBufferGeometry(table_x, 1, z1);

        elements_page.push([new THREE.Mesh(geometry, material), new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(table_x / 2, 1 / 2, z1 / 2)) }), "floor"]);








        // SHAPES LATERAIS
        var z2 = (table_z / 2 + (raio_ball * 8));
        var x2 = table_x / 2 - (raio_ball * 6);
        var groundShape2 = new CANNON.Box(new CANNON.Vec3(x2 / 2, 3 / 2, 1 / 2));
        groundShape2.material = wall_mat;

        var groundShape4 = new CANNON.Box(new CANNON.Vec3(1 / 2, 3 / 2, z2 / 2));
        groundShape4.material = wall_mat


        //      Lado 1 - 4
        //          THREEJS
        var g2 = new THREE.BoxBufferGeometry(x2, 3, 1);
        var m2 = new THREE.MeshStandardMaterial({ color: 0x663300 });

        //          CANNON
        for (var i = 0; i < 4; i++) {
            elements_page.push([new THREE.Mesh(g2, m2), new CANNON.Body({ mass: 0, shape: groundShape2 }), "wall"]);
        }

        // Lado 5-6
        g2 = new THREE.BoxBufferGeometry(1, 3, z2);
        for (var i = 0; i < 2; i++) {
            elements_page.push([new THREE.Mesh(g2, m2), new CANNON.Body({ mass: 0, shape: groundShape4 }), "wall"]);
        }


        // Bola Branca
        const gb = new THREE.SphereBufferGeometry(raio_ball, 320, 320);
        const mm = new THREE.MeshStandardMaterial({ color: 0xffffff });
        var gsg = new THREE.Mesh(gb, mm);

        var mass = 50, radius = raio_ball;
        var sphereShape = new CANNON.Sphere(radius); // Step 1
        sphereShape.material = new CANNON.Material({ friction: 0.1, restitution: 0.8 });
        var sphereBody = new CANNON.Body({ mass: mass, shape: sphereShape, position: new CANNON.Vec3(0, 11, 0) }); // Step 2
        sphereBody.angularDamping = 0.87;
        elements_page.push([gsg, sphereBody, "White"]);

        // Bolas Vermelhas
        const rb = new THREE.SphereBufferGeometry(raio_ball, 320, 320);
        const mb = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        mass = 2;
        for (var i = 0; i < 10; i++) {
            elements_page.push([new THREE.Mesh(rb, mb), new CANNON.Body({ mass: mass, shape: sphereShape, position: new CANNON.Vec3(0, 20 + 10 * i, 0) }), "Red"]);
        }

        // Pos inicial CAMERA
        camera.position.z = -5;
        camera.position.y = 20;

        // Adiciona tudo ao mundo
        var init_world = function () {
            if (scene.children.length > 0) {
                for (var i in elements_page) {
                    if (scene.children.includes(elements_page[i][0])) {
                        world.remove(elements_page[i][1]);
                        scene.remove(elements_page[i][0]);
                    }
                }
            }
            for (var i in elements_page) {
                world.add(elements_page[i][1]);
                scene.add(elements_page[i][0]);
            }
            setupKeyControls();
            setTimeout(function () {
                requestAnimationFrame(animate);
            }, 1000);
        };

        // Update de posição dos objetos
        function update_physics() {
            world.step((1 / FPS));
            for (var i in elements_page) {
                if (elements_page[i][2] == "White" && elements_page[i][1].position.y < -2 && all_stop()) {
                    elements_page[i][1].angularVelocity.set(0, 0, 0);
                    elements_page[i][1].velocity.set(0, 0, 0);
                    elements_page[i][1].force.set(0, 0, 0);
                    elements_page[i][1].inertia.set(0, 0, 0);
                    elements_page[i][1].position.set(table_z / 2, 1.03, 0);
                    elements_page[i][0].position.copy(elements_page[i][1].position);
                    elements_page[i][0].quaternion.copy(elements_page[i][1].quaternion);
                    pontuacao -= 5;
                }
                else if (elements_page[i][2] == "Red" && elements_page[i][1].position.y < -2) {
                    scene.remove(elements_page[i][0]);
                    world.remove(elements_page[i][1]);
                    pontuacao += 10;

                }
                else {
                    elements_page[i][0].position.copy(elements_page[i][1].position);
                    elements_page[i][0].quaternion.copy(elements_page[i][1].quaternion);
                }
            }
        }

        // Função de Update geral
        function animate() {
            if (all_stop()) {
                world.solver.iterations = 8;
            }
            else {
                world.solver.iterations = 800;
            }
            setTimeout(function () {
                requestAnimationFrame(animate);
            }, 1000 / FPS);
            controls.update();
            update_physics();
            console.log(scene.children.length);
            renderer.render(scene, camera);
        }


        reset_world();

        function setupKeyControls() {
            document.onkeydown = function (e) {
                switch (e.keyCode) {
                    case 82:
                        reset_world();
                        break;
                    case 74:
                        for (var ss in elements_page) {
                            if (elements_page[ss][2] == "White") {
                                elements_page[ss][1].applyForce(new CANNON.Vec3(-20000, 0, -2000), elements_page[ss][1].position);
                                break;
                            }
                        }
                        break;

                }
            };
        }

        var all_stop = function () {
            for (var i in elements_page) {
                if (elements_page[i][2] != "wall") {
                    if (elements_page[i][1].position.y > -2) {
                        if (Math.abs(elements_page[i][1].velocity.x) >= 0.001 & Math.abs(elements_page[i][1].velocity.z) >= 0.001) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function reset_world() {
            pontuacao = 0;
            init_world();
            var r = 0;
            var w = 0;
            for (var i in elements_page) {
                if (elements_page[i][2] == "White") {
                    elements_page[i][1].angularVelocity.set(0, 0, 0);
                    elements_page[i][1].velocity.set(0, 0, 0);
                    elements_page[i][1].force.set(0, 0, 0);
                    elements_page[i][1].inertia.set(0, 0, 0);
                    elements_page[i][1].position.set(table_z / 2, 1.03, 0);
                    elements_page[i][0].castShadow = true;
                    elements_page[i][0].recieveShadow = true;
                }
                else if (elements_page[i][2] == "Red") {
                    elements_page[i][1].angularVelocity.set(0, 0, 0);
                    elements_page[i][1].velocity.set(0, 0, 0);
                    elements_page[i][1].force.set(0, 0, 0);
                    elements_page[i][1].inertia.set(0, 0, 0);
                    elements_page[i][1].angularDamping = 0.6;
                    elements_page[i][0].castShadow = true;
                    elements_page[i][0].recieveShadow = true;
                    switch (r) {
                        case 0:
                            elements_page[i][1].position.set(-table_z / 2, 1.03, 0);
                            break;
                        case 1:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89, 1.03, 0.55);
                            break;
                        case 2:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89, 1.03, -0.55);
                            break;
                        case 3:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 2, 1.03, -0.55 * 2);
                            break;
                        case 4:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 2, 1.03, 0);
                            break;
                        case 5:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 2, 1.03, 0.55 * 2);
                            break;
                        case 6:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 3, 1.03, 0.55 * 3);
                            break;
                        case 7:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 3, 1.03, 0.55);
                            break;
                        case 8:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 3, 1.03, -0.55);
                            break;
                        case 9:
                            elements_page[i][1].position.set(-table_z / 2 - 0.89 * 3, 1.03, -0.55 * 3);
                            break;
                    }
                    r++;
                }
                else if (elements_page[i][2] == "floor") {

                    elements_page[i][0].castShadow = true;
                    elements_page[i][0].recieveShadow = true;
                    elements_page[i][1].position.set(0, 0, 0);

                }
                else {
                    switch (w) {
                        case 0:
                            elements_page[i][1].position.set(table_x / 4 - 0.4, 0, table_z / 2);
                            break;
                        case 1:
                            elements_page[i][1].position.set(-((table_x / 4) - 0.4), 0, table_z / 2);
                            break;
                        case 2:
                            elements_page[i][1].position.set(table_x / 4 - 0.4, 0, -table_z / 2);
                            break;
                        case 3:
                            elements_page[i][1].position.set(-((table_x / 4) - 0.4), 0, -table_z / 2);
                            break;
                        case 4:
                            elements_page[i][1].position.set(table_x / 2, 0, 0);
                            break;
                        case 5:
                            elements_page[i][1].position.set(-table_x / 2, 0, 0);
                            break;
                    }
                    w++;
                }
            }
        }
        export { pontuacao };

    </script>
</body>

</html>